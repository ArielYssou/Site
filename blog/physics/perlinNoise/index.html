<!DOCTYPE html>
<html lang='pt'>
	<head>

		<meta charset="ISO-8859-1">
		<meta name="viewport" content="width=device-width, intial-scale=1">

		<!-- Name on tab -->
		<title>Perlin Noise</title>

		<!-- Google Fonts -->
		<link href="https://fonts.googleapis.com/css?family=Cormorant+Garamond:400,700&display=swap" rel="stylesheet"> 

		<!-- Custom CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
		<link rel="stylesheet" href="../../../css/style.css"> <!--TARGET-->
		<link rel="stylesheet" href="../../../css/pygments.css"> <!--TARGET-->

		<script src="https://cdn.jsdelivr.net/npm/p5@0.10.2/lib/p5.js"></script>

		<!-- Custom p5js animations -->
		<script src="sketch.js"></script>
		<script src="perlinMaze.js"></script>

	</head>

	<body>
		<!-- Navigation bar -->
		<nav class="navbar navbar-expand-lg navbar-dark fixed-top navbar-custom">
			<a class="navbar-brand" href="../../.." style="font-weight:bold;">Ariel Yssou</a> <!--TARGET-->
			<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav mr-auto">
					<li class="nav-item">
						<a class="nav-link" href="../../.." style="font-weight:bold;">Home </a><!--TARGET-->
 
					</li>
					<li class="nav-item nav-blog active">
						<a class="nav-link" href="../../" style="font-weight:bold;">Blog <span class="sr-only">(current)</span></a><!--TARGET-->
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../../../gallery" style="font-weight:bold;">Gallery </a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../../../about" style="font-weight:bold;">About</a><!--TARGET-->
					</li>
				</ul>
			</div>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav ml-auto">
					<li class="nav-item">
						<a class="nav-link text-nowrap" href="https://github.com/ArielYssou" target="_blank"><i class="fab fa-github fa-lg"></i></a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-nowrap" href="https://www.linkedin.com/in/ariel-yssou-oliveira-f-2a07a5b5/" target="_blank"><i class="fab fa-linkedin fa-lg"></i></a>
					</li>
				</ul>
			</div>
		</nav>
		<!-- End of navigation bar -->
		
		<div class="head_container">
			<img src="./cover_image.png" class="head_image no_blur">
			<div class="head_middle">
				<div class="head_text"><b>Perlin Noise</b></div>
			</div>
		</div>

		<div class="container post_body">
			<div class="row post_struct">
				<div class="col-ld-12">

					<p>Random events are present in many physical systems and create several intriguing behaviors and beautiful patterns. Although many things are apparently $``$random$''$, they are actually deterministic, just extremely complex. We can't generate infinitely complex functions or simulate something truly random in a deterministic machine (i.e. a computer), so how can we simulate $``$natural randomness$"$? Computer generated randomness may feel artificial as it is perfectly random and don't exhibit any correlations that are generated by the rich structures we in real systems. In this post we will discuss one very interesting way of simulating this kind of randomness using <b>Perlin noise</b>.</p>
					<img src="collage.jpg" alt="Nature Random Paterns", class="img_format">

					<!-- TOC -->
 <table class="TOC">
  <tr><th>Contents</th></tr>
	<tr><td><a href="#INTRO">1. Introduction</a></td></tr>
	<tr><td><a href="#PERLIN">2. Perlin Noise<F9></a>	</td></tr>
	<tr><td><a href="#CODE">3. Applications</a></a></td></tr>
</table> 
<br></br>
					<a name="INTRO"></a>
					<h2 class="section">1. Introduction</h2>
					<p>
					<p>Lets by discussing how we can generate simple sequences of random numbers. (it's actually <a href="https://en.wikipedia.org/wiki/Random_sequence" target='_'>not trivial</a> to define what is a random sequence is, so we will not delve too much into it in this post). As there is no way of generating undeterministic numbers in a deterministic machine (AKA a computer), random sequences are created using <b>pseudo random number generators (PRNG)</b>, which generate periodic sequences that behaves randomly in each full period. The catch is that the functions period is so big that, in practice, we will never reach it.
					</p>
					<p>
					PRNGs are used in academical models as they don't introduce any unwanted correlations into the system, but in our case we want correlations in the generator. These correlations must be complex enough that they don't generate any obvious patterns, but no too complex so their effect can be observed to some extent. Our task will be to transform this random pattern (such as the one on the left generated with an PRNG) to look more like an noise observed in nature, such as the pattern in rain clouds (right):
					</p>
					<figure>
						<img src="random_noise.jpg" alt="Random Noise" class='img_format'>
					</figure>
					<figure>
						<img src="dry_paint.jpeg" alt="Dry paint" class='img_format'>
					<figure>
					<a name="PERLIN"></a>
					<h2 class="section">2. Perlin Noise</h2>
				<p>
				As our objective is quite vague (to generate a function that resembles natural noises), there will be no truly correct answer. The most simple way of doing this is by just interpolation a function to a sequence of evenly spaced random numbers. The resulting function will have highly correlated values locally but will behave randomly in a global scale. This method can be used to create a virtually infinite number of noise functions depending on the PRGN used and on the interpolation function. Each one of this solutions is acceptable, but there are some things that we must consider.
				<ul>
					<li>Computational efficiency: The function can't be too complex so it becomes computationally unwieldy;</li>
					<li>Complexity: The function can't be too simple so the resulting patters is boring and too simple;</li>
					<li>Random: The interpolation must be complex enough so it remains random globally.</li>
				</ul>
				</p>
				<p>
				One interesting algorithm that solve all these questions was created by Ken Perlin in the 80s when he was trying to make realistic textures for the movie Tron (which won the Oscar for especial effects, part due to his noise algorithm!). His algorithm uses the same rationale we discussed of generating random values and then interpolating a function. His final code had all the properties desired from a noise function: it was concise, very fast and still behaved randomly. This was not an easy task as he had to published several papers until he came with the final formulation of his algorithm, but the results where fascinating:
				</p>
				<!--<figure>
					<img src="neg_plot.png" alt="Random Noise" class='img_format'>
					<figcaption>\(1D\) Perlin noise function.</figcaption>
				</figure>-->
				<p>
				This pattern is continuous locally but globally has a nice random feel to it. We can use it to simulate several interesting things, specially when we don't want to actually model a complex system, but still simulate its behavior. In the next session we will implement some simple examples to observe the effects of Perlin Noise.
				</p>
				
				<a name="CODE"></a>
				<h2 class="section">2. Applications</h2>
				<p>
				Lets implement some simple system where we can observe the effects of the Perlin Noise function.
				</p>
				<h3>Procedural Caves</h3>
				<p>
				Our first example will use the noise function itself to generate a maze (or a RPG dungeon!). Lets start by remembering the Perlin noise is built interpolating a function to a grid of random values. This generates a continuous space of locally correlated values but random in a global scale. We will refer to this space as the <b>noise space</b>. If we take several points in a small neighborhood they will be very similar, but if the points are take from distant places they will be uncorrelated. Indeed, we can pick values from the noise space in small or huge steps, and this will generate very different patterns:
				</p>
				<p>
				We can apply a threshold function (Heavyside theta) so all noise values above a certain value are set to $1$ and all below will be set to $0$. This creates a labyrinthine pattern:
				<div class = 'sketch-holder' id="perlinMaze"></div>
				The pattern itself will be different depending on where we pick the values in the noise space. This allows us to generate different maps in a procedural way:
				</p>
				<div class = 'sketch-holder' id="ink"></div>
				<p>
				But this is just an image, we need to convert it into an object so it can be used in a code or engine(to detect collisions, for example). To do this we need to:
				</p>
				<ol>
					<li>Detect clusters of active sites</li>
					<li>Generate the borders of each cluster</li>
				</ol>
				<h4>Cluster Detection</h4>
				<p>
				To detect the clusters of active sites efficiently we will implement the <b>Hoshen - Kopelman</b> algorithm. The algorithm is based on a raster scan (a horizontal sweep on the lattice from left-to-right at a steady rate) and a union-find algorithm (also know as disjoint-set or merge-set). The union - find operation generates equivalence classes, thus the <code>union(A, B)</code> specifies whether two classes, $A$ and $B$, are equivalent (members of the same equivalence class). As equivalences are transitive ($A \equiv B \Leftrightarrow B \equiv A$) so all the items labeled as $A$ are equivalent to all the items labeled as $B$. 
				</p>
				<p>
				During the raster scan we label each active site (i.e. $noise \geq threshold$) based on its neighbors. If some neighbor then is already labeled, the current site inherits its label. If no neighboring site is labeled, we assign it a new label and go to the next. This procedure does not guarantee that all sites in the same cluster will have the same label, so we need to set equivalence classes to unite all labels inside each cluster. For details on the implementation please refer to <a href="https://en.wikipedia.org/wiki/Hoshen%E2%80%93Kopelman_algorithm" target='_'>this wiki page</a> page and <a href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjK-rz9zdPsAhVRA9QKHYbTAgYQFjAAegQIBhAC&url=https%3A%2F%2Fwebhome.weizmann.ac.il%2Fhome%2Ffeamit%2Fnodalweek%2Fc_joas_nodalweek.pdf&usg=AOvVaw3AwGXXqVZN-mBWmjoB3YTl" target='_'>this technical presentation</a>, as the wiki pseudo code is <b>very</b> confusing and needs further insights. Here is y implementation in JS:
				<!--COde-->
				If we apply this final algorithm to the Perlin maze that we generated previously the result is as intended:
				<div class = 'sketch-holder' id="perlinMazeClusters"></div>
				</p>
				<h4>Border detection</h4>
				<p>
				This task is more challenging than the previous as defining the border of an arbitrary irregular polygon is no so simple (as there are many possibles borders for the same polygon). One solution might be to try to identify all sites on the exterior in a visual manner (pick an external site, look in all direction, add the first occupied site in each direction to an array. Repeat for all external points). This, however, is very inefficient and does not generates an ordered array, so we would still need to built yet another algorithm to determine the correct order of points on the border. Another limitation is that a cluster may have internal holes, which are hard to differentiate from the external hull.
				</p>
				<p>
				A more elegant solution would be to determine the <b>convex hull</b> of the cluster in a single pass. For this we implement the <a href="https://en.wikipedia.org/wiki/Graham_scan" target='_'><b>Grahan scan</b></a>  algorithm, which uses a stack to detect and remove concavities in the boundary efficiently. This is not an ideal solution as it only detects a hull that encompass the entire cluster (like a gift wrap), but is not exactly the true exterior hull. As we want to focus on the Perlin noise we will not go into the implementation itself, but you can read more about it <a href="https://en.wikipedia.org/wiki/Graham_scan" target='_'>here</a>. The resulting code identifies the hull of each cluster in our maze:
				</p>
				<div class = 'sketch-holder' id="perlinMazeHull"></div>
				<p>
				An even better solution would be to find a <b>concave hull</b> for each cluster, which would be the ideal solution. We will dedicate a entire post for this problem as the implementation is very interesting and deserves proper attention.
				</p> 	
				<h3>Unstable orbits 1</h3>
				<p>
				Movements in nature usually are perturbated by random exterior forces. We can simulate small perturbations in a particle submitting it to a force whose magnitude is given by the Perlin noise function. As a linear trajectory would be hard to visualize (the particle would just escape the canvas), we will implement a circular motion with a noisy radial force:
				</p>
				<div class = 'sketch-holder' id="circularMotion"></div>
				<!-- Circular motion -->
				<p>
				This code was made by just adding or subtracting a random value from the radius at each step, keeping the angular speed constant. This system has no physical significant as no force in nature acts like this and we made no considerations about the total angular momentum, and serves only as a interesting visualization of the Perlin function. In the next examples we will build an actual physics engine with random forces!
				</p>
				<h3>Perlin field</h3>
				<p>
				An interesting application of the Perlin noise is to use it as a force field. As forces are vectors, we need to not only generate a value at each position, but a direction as well. Daniel Shiffman made and <a href='https://www.youtube.com/watch?v=BjoM9oKOAKY' target='_'>excellent video</a> about this application and I highly recommend it (as he is not only an amazing programmer, but also emanates good vibes). His idea was to use the noise space values as random orientations, generating vectors at each position based on this random orientation.
				</p>
				<p>
				The implementation is too big for this post so we will just outline it: The force field is generated as random unit vectors whose directions are given by the noise function (mapped to a $0$ $2\pi$ interval). Each particle has a position, speed and acceleration, and at each step we update its acceleration with the force on its current position, then we update its speed and position accordingly. Plotting the trajectory of some particles in this field we get this mesmerizing pattern:
				</p>
					<p><span class='alert'>Click on the panel bellow to start/stop the simulation.</span> (In some browsers is necessary to click twice to unpause because I screwed the html in some unknown way)</p>
					<div class = 'sketch-holder' id="perlin_field"></div>
				<p>
				We can add a central potential to the force field to generate random orbits as well (as a contrast to the $``$hard coded$"$ random circular motion of the last example):
				</p>
				<div class = 'sketch-holder' id="perlin_alt"></div>
				These are just some simple applications of the Perlin noise and I hope they inspire you to make some beautiful visualizations and some interesting simulations! Thanks for reading :D
<br>
<p>Code:</p>
<pre>
{% include 'particle_code.js' %}
</pre>
<pre>
{% include 'sketch.js' %}
</pre>

				</div>
			</div>
		</div>

		<hr/>
		<script src="../../../js/script.js"> </script><!--TARGET-->
		<!-- Bootstrap + JQuery -->
		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

		<script src="https://kit.fontawesome.com/9ead9d8df4.js" crossorigin="anonymous"></script>

    <!-- mathjax -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>

	</body>
</html>
