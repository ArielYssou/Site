<!DOCTYPE html>
<html lang='pt'>
	<head>

		<meta charset="ISO-8859-1">
		<meta name="viewport" content="width=device-width, intial-scale=1">

		<!-- Name on tab -->
		<title>Perlin Noise</title>

		<!-- Google Fonts -->
		<link href="https://fonts.googleapis.com/css?family=Cormorant+Garamond:400,700&display=swap" rel="stylesheet"> 

		<!-- Custom CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
		<link rel="stylesheet" href="../../../css/style.css"> <!--TARGET-->
		<link rel="stylesheet" href="../../../css/pygments.css"> <!--TARGET-->

		<script src="https://cdn.jsdelivr.net/npm/p5@0.10.2/lib/p5.js"></script>

		<!-- Custom p5js animations -->
		<script src="sketch.js"></script>
		<script src="perlinMaze.js"></script>

	</head>

	<body>
		<!-- Navigation bar -->
		<nav class="navbar navbar-expand-lg navbar-dark fixed-top navbar-custom">
			<a class="navbar-brand" href="../../.." style="font-weight:bold;">Ariel Yssou</a> <!--TARGET-->
			<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav mr-auto">
					<li class="nav-item">
						<a class="nav-link" href="../../.." style="font-weight:bold;">Home </a><!--TARGET-->
 
					</li>
					<li class="nav-item nav-blog active">
						<a class="nav-link" href="../../" style="font-weight:bold;">Blog <span class="sr-only">(current)</span></a><!--TARGET-->
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../../../gallery" style="font-weight:bold;">Gallery </a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../../../about" style="font-weight:bold;">About</a><!--TARGET-->
					</li>
				</ul>
			</div>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav ml-auto">
					<li class="nav-item">
						<a class="nav-link text-nowrap" href="https://github.com/ArielYssou" target="_blank"><i class="fab fa-github fa-lg"></i></a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-nowrap" href="https://www.linkedin.com/in/ariel-yssou-oliveira-f-2a07a5b5/" target="_blank"><i class="fab fa-linkedin fa-lg"></i></a>
					</li>
				</ul>
			</div>
		</nav>
		<!-- End of navigation bar -->
		
		<div class="head_container">
			<img src="./cover_image.png" class="head_image no_blur">
			<div class="head_middle">
				<div class="head_text"><b>Perlin Noise</b></div>
			</div>
		</div>

		<div class="container post_body">
			<div class="row post_struct">
				<div class="col-ld-12">

					<p>Random events are present in many physical systems and create several intriguing behaviors and patterns. In fact, many systems in nature that we call $``$random$''$ are actually deterministic, but just extremely complex and our brains can't comprehend all the patterns in the system as a whole. Computer generated randomness may feel artificial as it is perfectly random and don't exhibit any correlations that generate the rich structures we observe in $``$natural randomness$"$. In this post we will discuss methods to generate random patterns that resemble natural noises, focusing on the famous Perlin noise. We will also discuss some applications as well.</p>
					<img src="collage.jpg" alt="Nature Random Paterns", class="img_format">

					<!-- TOC -->
 <table class="TOC">
  <tr><th>Contents</th></tr>
	<tr><td><a href="#INTRO">1. Introduction</a></td></tr>
	<tr><td><a href="#PERLIN">2. Perlin Noise<F9></a>	</td></tr>
	<tr><td><a href="#CODE">3. Applications</a></a></td></tr>
</table> 
<br></br>
					<a name="INTRO"></a>
					<h2 class="section">1. Introduction</h2>
					<p>
					<p>Lets start our discussion by discussing how we can generate simple random numbers. For this we will need first to define exactly what $``$ random$"$ means. A sequence of numbers is denoted as $``$random$"$ if we cannot fully determine which will be the next element of the sequence even if we know an arbitrary number of past elements (this may not be the most mathematically exact definition, but we will stick with it and ignore any angry mathematician in the audience).
					</p>
					<p>
					As there is no way of generating undeterministic numbers in a computer (thus deterministic), we will create a <b>pseudo random number generator (PRNG)</b>, which is a method to generate sequences that are periodic but inside each period the sequence behaves randomly. The idea here is that the function period is so big that, in practice, we will never reach it. There are many interesting this to discuss about PRNGs, but we will leave this discussion to a separate post.
					</p>
					<p>
					PRNGs are used in academical models as they don't introduce any unwanted correlations into the system, but in our case we want correlations in the generator.These correlations must be complex enough that they don't generate obvious patterns, but no too complex so their effect can be observed in some way. Our task will be to transform this random pattern (such as the one on the left generated with an PRNG) to look more like an noise observed in nature (such as the pattern in clouds, as illustrated on the right image):
					</p>
					<figure>
						<img src="random_noise.jpg" alt="Random Noise" class='img_format'>
					</figure>
					<figure>
						<img src="dry_paint.jpeg" alt="Dry paint" class='img_format'>
					<figure>
					<a name="PERLIN"></a>
					<h2 class="section">2. Perlin Noise</h2>
				<p>
				As our objective is quite loose (to generate a function that resembles natural noises), there is no correct answer. The most simple way of doing this is by just interpolation a function to a sequence of evenly spaced random numbers. The resulting function will have lightly correlated values locally but will behave randomly in a global scale. This method can be used to create a virtually infinite number of noise functions depending on the PRGN used and the interpolation function. Each one of this solutions is acceptable, but there are some things that we must consider.
				<ul>
					<li>Computational efficiency: The function can't be too complex so it becomes computationally unwieldy;</li>
					<li>Complexity: The function can't be too simple so the resulting patters is boring and too simple</li>
					<li>Random: The interpolation must be complex enough so it remains random globally.</li>
				</ul>
				<p>
				One interesting algorithm that solve all these questions was created by Ker Perlin in the 80s when he was trying to make realistic textures to the movie Tron (which won the Oscar for especial effects in part due to his noise algorithm!). His algorithm uses the same rationale of generating random values and then interpolating a function, but the final code was concise, very fast and still behaved randomly. This was not an easy task as he had to published several papers until he came with the final formulation of his algorithm, but the results where fascinating:				</p>
				<!--<figure>
					<img src="neg_plot.png" alt="Random Noise" class='img_format'>
					<figcaption>\(1D\) Perlin noise function.</figcaption>
				</figure>-->
				<p>
				This pattern is continuous locally but globally has a nice random feel to it. We can use it to simulate several interesting things, specially when we don't want to actually model a complex system, but still simulate its behavior. In the next session we will implement some simple cases to observe the effects of perlin noise.
				</p>
				
				<a name="CODE"></a>
				<h2 class="section">2. Applications</h2>
				<p>
				Lets implement some simple system where the effects of the Perlin Noise function are explicit. 
				</p>
				<h3>Procedural Caves</h3>
				<p>
				Our first example will use the noise function itself to generate a maze or dungeon! Lets start by remembering the Perlin noise is built interpolating a function to a grid of random values. This generates a continuous space of locally correlated values but random in a global scale. We will refer to this space as the <b>noise space</b>. If we take several points in a small neighborhood they will be very similar, but if the points are take from distant places they will be uncorrelated. Indeed, we can pick values from the noise space in small or huge steps, and this will generate very different patterns:
				</p>
				<div class = 'sketch-holder' id="perlinMaze"></div>
				<p>
				We can apply a threshold function (Heavyside theta) so all noise values above a certain value are set to $1$ and all below will be set to $0$. This generates a maze-like pattern. The resulting maze will be different depending on where we pick the noise values, so this allow us to generate different maps in a procedural way. If we transverse the noise space and generate a new pattern on each iteration the maze will vary in a interesting way:
				</p>
				<div class = 'sketch-holder' id="ink"></div>
				<p>
				But this is just an image, we need to convert it into an object so it can be used (to detect collisions, for example). To do this we need to:
				</p>
				<ol>
					<li>Detect clusters of active sites</li>
					<li>Generate the borders of each cluster</li>
				</ol>
				<h4>Cluster Detection</h4>
				<p>
				To detect the clusters of active sites efficiently we will implement the <b>Hoshen - KopelMan</b> algorithm. The algorithm is based on a raster scan (a horizontal sweep on the lattice from left-to-right at a steady rate) and a union-find algorithm (also know as disjoint-set or merge-set). The union - find operation generates equivalence classes, thus the <code>union(A, B)</code> specifies that classes $A$ and $B$ are equivalent (members of the same equivalence class). As equivalence are transitive ($A \equiv B \Leftrightarrow B \equiv A$) we have that all the items labeled as $A$ are equivalent to all the items labeled as $B$. 
				</p>
				<p>
				During the raster scan we label each active site (i.e. $noise \geq threshold$) based on its neighbors. If some of then is already labeled, the current site inherits the label from the neighbor. If no neighboring site has a label, we assign it a new label and go to the next. This procedure, however, does not guarantee that all sites in the same cluster will have the same label, so we need to set equivalence classes to unite all labels inside each cluster. For details on the implementation please refer to this wiki page and this more technical presentation, as the wiki pseudo code in the wiki is <b>very</b> confusing. My implementation is as follows:
				<!--COde-->
					<div class = 'sketch-holder' id="perlinMazeClusters"></div>
				If we apply this final algorithm to the Perlin maze that we generated previously the result is as intended:
				</p>
				<h4>Border detection</h4>
				<p>
				This task is more challenging than the previous as defining the border of an arbitrary irregular polygon is no so simple. One solution might be to try to identify all sites on the exterior on a visual manner (pick an external site, look in all direction, add the first occupied site in each direction to an array (if already not included). Repeat for all external points.). This, however, is very inefficient and does not generates an ordered array, so we would still need to buil yet another algorithm to determine the correct order of points on the border. Another limitation is that a cluster may have internal holes, so how we differentiate these holes from the external hull?
				</p>
				<p>
				A more elegant solution would be to determine the <b>convex hull</b> of the cluster in a single pass. For this we implement the <b>Graham scan</b> algorithm, which uses a stack to detect and remove concavities in the boundary efficiently. This is not an ideal solution as it only detects a hull that encompass the entire cluster, like a gift wrap, but is not exactly the true exterior hull. For now we want to focus on the Perlin noise,so we will not go into the implementation itself, but you can read more about it <a href="https://en.wikipedia.org/wiki/Graham_scan" target='_'>here</a>. The resulting code identifies the hull of each cluster in our maze:
				</p>
				<div class = 'sketch-holder' id="perlinMazeHull"></div>
				<p>
				A even better solution would be to find a <b>concave hull</b> for each cluster, which would be the ideal solution. We will dedicate a entire post for this problem as the implementation is very interesting and deserves proper attention.
				</p> 	
				<h3>Unstable orbits 1</h3>
				<p>
				Movements in nature usually are perturbated by random exterior forces. To simulate a particle suffering from small perturbations we can make its speed (or acceleration) be perturbated via a Perlin noise. To illustrate this we can implement a perturbated circular motion where the radial speed is affected by a noise. A linear motion would be hard to visualize as the particle would just escape the canvas. This system would look like this:
				</p>
				<div class = 'sketch-holder' id="circularMotion"></div>
				<!-- Circular motion -->
				<p>
				A nice thing to consider is if the total angular momentum of the system is affected by this external force. As the noise was 'hard coded' into the system and did not use any conservation law to update the angular speed accordingly (as implementing these dynamics would affect performance a little bit), the conservation laws do not apply. A interesting exercise would be to implement this system with a physics system. In the next examples we will start to build an actual physics engine with random forces!
				</p>
				<h3>Perlin field</h3>
				<p>
				An interesting application of the perlin noise is to use it as a force field. As forces are vectors, we need to not only generate a value at each position, but a direction as well. Daniel Shiffman made and <a href='https://www.youtube.com/watch?v=BjoM9oKOAKY' target='_'>excellent video</a> about this application and I highly recommend it (as he is not only an amazing programmer, but also emanates good vibes). His idea was to use the noise space values as random orientations, and generate vectors at each position based on this orientation.
				</p>
				<p>
				The implementation is too big for this post so we will just outline it. The force field is generated as random unit vectors whose directions are given by the noise function (mapped to a $0$ $2\pi$ interval). Each particle has a position, speed and acceleration, and at each step we update its acceleration as the force on its position, then update its speed and position accordingly. If we plot the trajectory of some particles in this field we get this pattern:
				</p>
					<p><span class='alert'>Click on the panel bellow to start/stop the simulation.</span> (In some browsers is necessary to click twice to unpause because I screwed the html in some unknown way)</p>
					<div class = 'sketch-holder' id="perlin_field"></div>
				<p>
				We can add a central potential to the force field to generate random orbits as well:
				</p>
				<div class = 'sketch-holder' id="perlin_alt"></div>
				These are just some simple applications of the Perlin noise! I hope the inspire you to make some beautiful visualizations and some interesting simulations! Thanks for reading :D
<br></br>
<p>Code:</p>
<pre>
{% include 'particle_code.js' %}
</pre>

					<div class="row">
						<div class="col">
						</div>
						<div class="col">
						</div>
					</div>

					<p>I hope you liked it! There are many other interesting visualisations that can be achieved using a simple noise function. In the future I'll try to generate terrain with Perlin noise and see if we can make the classical vaporwave sunset that we all know and love. Until the next time, bye :D</p>

					<p>Full code:</p>
<pre>
{% include 'sketch.js' %}
</pre>

				</div>
			</div>
		</div>

		<hr/>
		<script src="../../../js/script.js"> </script><!--TARGET-->
		<!-- Bootstrap + JQuery -->
		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

		<script src="https://kit.fontawesome.com/9ead9d8df4.js" crossorigin="anonymous"></script>

    <!-- mathjax -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>

	</body>
</html>
