<!DOCTYPE html>
<html lang='pt'>
	<head>

		<meta charset="ISO-8859-1">
		<meta name="viewport" content="width=device-width, intial-scale=1">

		<!-- Name on tab -->
		<title>Perlin Noise</title>

		<!-- Google Fonts -->
		<link href="https://fonts.googleapis.com/css?family=Cormorant+Garamond:400,700&display=swap" rel="stylesheet"> 

		<!-- Custom CSS -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
		<link rel="stylesheet" href="../../../css/style.css"> <!--TARGET-->
		<link rel="stylesheet" href="../../../css/pygments.css"> <!--TARGET-->

		<script src="https://cdn.jsdelivr.net/npm/p5@0.10.2/lib/p5.js"></script>

		<!-- Custom p5js animations -->
		<script src="sketch.js"></script>
		<script src="perlinMaze.js"></script>
		<script src="waterBall.js"></script>

	</head>

	<body>
		<!-- Navigation bar -->
		<nav class="navbar navbar-expand-lg navbar-dark fixed-top navbar-custom">
			<a class="navbar-brand" href="../../.." style="font-weight:bold;">Ariel Yssou</a> <!--TARGET-->
			<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav mr-auto">
					<li class="nav-item">
						<a class="nav-link" href="../../.." style="font-weight:bold;">Home </a><!--TARGET-->
 
					</li>
					<li class="nav-item nav-blog active">
						<a class="nav-link" href="../../" style="font-weight:bold;">Blog <span class="sr-only">(current)</span></a><!--TARGET-->
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../../../gallery" style="font-weight:bold;">Gallery </a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="../../../about" style="font-weight:bold;">About</a><!--TARGET-->
					</li>
				</ul>
			</div>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav ml-auto">
					<li class="nav-item">
						<a class="nav-link text-nowrap" href="https://github.com/ArielYssou" target="_blank"><i class="fab fa-github fa-lg"></i></a>
					</li>
					<li class="nav-item">
						<a class="nav-link text-nowrap" href="https://www.linkedin.com/in/ariel-yssou-oliveira-f-2a07a5b5/" target="_blank"><i class="fab fa-linkedin fa-lg"></i></a>
					</li>
				</ul>
			</div>
		</nav>
		<!-- End of navigation bar -->
		
		<div class="head_container">
			<img src="./cover_image.png" class="head_image no_blur">
			<div class="head_middle">
				<div class="head_text"><b>Perlin Noise</b></div>
			</div>
		</div>

		<div class="container post_body">
			<div class="row post_struct">
				<div class="col-ld-12">

					<div class = 'sketch-holder' id="waterBall"></div>
					<!--<div class = 'sketch-holder' id="perlinMaze"></div>-->
					<p>Random events are present in many physical systems, and create several intriguing behaviors and patterns. There are many ways of simulation randomness, but some feel $``$artificial$"$, but why? Real world patterns have a rich and complex structure as their randomness is generated via several interacting dynamics, which are hard to simulate in a computer. In this post we will explore some of the history of this problem and discuss one famous way of generating random noises that can be used to generate mesmerizing patterns, the Perlin noise (this is perhaps the first algorithm that lead to an Oscar award!)</p>
					<img src="collage.jpg" alt="Nature Random Paterns", class="img_format">

					<!-- TOC -->
 <table class="TOC">
  <tr><th>Contents</th></tr>
	<tr><td><a href="#INTRO">1. Introduction</a></td></tr>
	<tr><td><a href="#PERLIN">2. Perlin Noise<F9></a>	</td></tr>
	<tr><td><a href="#CODE">3. Demos</a></a></td></tr>
</table> 
<br></br>
					<a name="INTRO"></a>
					<h2 class="section">1. Introduction</h2>
					<p>
					<p>Lets start our discussion by discussing how we can generate simple random numbers, for this we need to define exactly what $``$ random sequence$"$ means. For our intents and purposes we can call a sequence of numbers $``$random$"$ if we cannot fully determine which will be the next element of the sequence even if we know an arbitrary number of past elements (this may not be the most mathematically exact definition, but we will stick with it and ignore any angry mathematician). As there is no way of generating undeterministic number in a computational (thus deterministic), we will create a pseudo random number generator (PRNG), which is just a fancy name of a noisy function with a huge periodic behavior. The idea here is that the period of this function is so big that we will never reach it in practice, thus only observing the noisy, unpredictable, part.
					</p>
					<p>
					This PNGR can only generate an finite number of random numbers until we reach its period, after this we can predict any further elements with 100% precision, which would introduce unwanted correlations into our random system. There are many observations to be made here about computational efficiency and we should also formulate a rigorous mathematical background, but these topics will be left for a future, more technical, post. For now we will just accept the already implemented PRNG that all computer languages have and focus on the topic of noises.
					</p>
					<p>
					PRNG can be used in academical models as they don't introduce any unwanted correlations into the system. Albeit this is a desirable property in a statistical model, it can be a noisence when trying to replicate an isolated pattern. Two neigboring elements in a sequence generated by a PRNG can be wildly different, and this kind of extreme discontinuity is not observed in real world systems as almost no observable physical system can have discontinuities in it. We can observe how $``$unnatural$"$ a pattern generated via an PRNG is if we just use it plot a sequence of shades of gray:
					</p>
					<figure>
						<img src="random_noise.jpg" alt="Random Noise" class='img_format'>
					</figure>
					<p>
					Our task now is to modify the PRNG to generate a more smooth sequence that still has a random behavior so we can generate a more natural patterns such as this
					</p>
					<figure>
						<img src="dry_paint.jpeg" alt="Dry paint" class='img_format'>
					<figure>
					<a name="PERLIN"></a>
					<h2 class="section">2. Perlin Noise</h2>
				<p>
				To transform our random sequence into an natural noise we must introduce continuity to it. There are some simple ways of doing this such as just interpoliting a function to the noise values. Indeed this solution may seem very simple, but it has some bottlenecks. The interpolated function must be computationally efficient as we may want to generate many random values without waiting days for the sequence to be generated. Another limitation is that its very hard to tune the complexity of this interpolation function. If its too simple it will loose much of the noise feel, but if its too complex it will be very computationally costly.
				</p>
				<!--1D NOISE -->
				<p>
				This problem was tackled by Ken Perlin in the 80s when he was trying to make realistic textures to the movie Tron, which came to win the Oscar for especial effects (in part due to Ken's noise algorithm!). His algorithm uses the same rationale of generating random values and then interpolating then with an function, but the final code was concise and very very fast. This was not an easy task as he had to published several papers until he came with the final formulation of his algorithm. But the results where fascinating. If we make the same visualization of just plotting colors based on the random sequence but using Perlin's function instead of the PRNG we can see the differences very clearly: 
				</p>
				<figure>
					<img src="neg_plot.png" alt="Random Noise" class='img_format'>
					<figcaption>\(1D\) Perlin noise function.</figcaption>
				</figure>
				<p>
				Of course there are more interesting applications than just plotting greys into the screen, so lets take a look at some possibilities.
				
				<a name="CODE"></a>
				<h2 class="section">2. Demos</h2>
				<p>
				Of course that the number of applications for a function that simulates natural noises is vast. Lets take a look into some demonstrations of different complexities
				</p>
				<h3>Procedual Caves</h3>
				<p>
				A simple way of using the noise function is just truncating all noise values to be either $0$ or $1$ based on a threshold. This gives us the following pattern:
				This patter is very simmilar to an cave or dungeon! We could generate an map for an RPG based on this first approximation. TO make it more interesting, we can 

				</p>
 This schema to build a noise function is fairly simple, so we might as well build our own noise function. A worthwhile read about this topic can be found in the <a href="https://thebookofshaders.com/11/" target='_'>Book of Shaders</a>, which has some very nice ideas for possible visualizations of noise.
				<p>As the number of possible applications is almost infinite (a funny expression as nothing is truly 'almost infinite'), we will start with a classical one: generating a force field where the direction of the forces are generated via a noise function. Writing a step by step implementation would be very dull to write (and almost lethally boring to read) so I will just describe the key insights and refer to Daniel Shiffman <a href='https://www.youtube.com/watch?v=BjoM9oKOAKY' target='_'>excellent video</a>  (his entire Youtube channel is amazing and a must see for all code enthusiasts)</p>
				<p>To visualize the field one might plot the usual arrow stream that consists of basically putting an arrow to represent the field in each point of a grid. But a far more beautiful way to visualize the effects of such a field is to generate particles that are subjected to the forces and plot their trajectory. The most 'logical' way to implement this is to create a <code>Particle()</code> generator function (or class if you wish), that generates a particle objects (in JavaScript a prototype object of the class, in python and most decent programming languages a instance of the class). There are many ways to implement the force field, I just set the module of all forces to 1 and generated a random direction via a noise function (not in a \(2\pi\) range to give a "global direction" to the field). Here is the code for the generator function (one of many ways of doing this in JS):</p> 	
<br></br>
<pre>
{% include 'particle_code.js' %}
</pre>
				<p>Each particle holds its current and previous positions and at each step we pot a line between then. Here is the final result</p>
					<p><span class='alert'>Click on the panel bellow to start/stop the simulation.</span> (In some browsers is necessary to click twice to unpause because I screwed the html in some unknown way)</p>
					<div class = 'sketch-holder' id="perlin_field"></div>
					<p>I experimented with some ideas that I had, like adding a central potential to the field (achieving orbits is quite impossible without cheating (adding radial noise that don't affect the circular motion) and sowing only regions where the noise function is bigger than a given threshold (I presume that some video game use this method or some variant to generate maps. If not I just gave you a nice idea for a game).</p>
					<p><span class='alert'>Click on the panels bellow to start/stop the simulation.</span> (In some browsers is necessary to click twice to unpause because I screwed the html in some unknown way)</p>

					<div class="row">
						<div class="col">
							<div class = 'sketch-holder' id="perlin_alt"></div>
						</div>
						<div class="col">
							<div class = 'sketch-holder' id="ink"></div>
						</div>
					</div>

					<p>I hope you liked it! There are many other interesting visualisations that can be achieved using a simple noise function. In the future I'll try to generate terrain with Perlin noise and see if we can make the classical vaporwave sunset that we all know and love. Until the next time, bye :D</p>

					<p>Full code:</p>
<pre>
{% include 'sketch.js' %}
</pre>

				</div>
			</div>
		</div>

		<hr/>
		<script src="../../../js/script.js"> </script><!--TARGET-->
		<!-- Bootstrap + JQuery -->
		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

		<script src="https://kit.fontawesome.com/9ead9d8df4.js" crossorigin="anonymous"></script>

    <!-- mathjax -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>

	</body>
</html>
